{"data":{"type":"contents","id":"index","attributes":{"html":"<h1 id=\"welcome\">Welcome</h1>\n<p>This add-on aims to resolve the form validation on your WEB development. Yes, it can be straightforward build a simple solution by listening the <code>input</code> event and disable the <code>continue</code> button until it's correct. But that's clearly not always the case, especially when the project involve tons of user input. Normally a form validation library can ease the pain and setup a certain standard for consistency. Well, this is one of them, however, we are trying build a tool that is more versatile and not stop you the way.</p>\n<h2 id=\"buildforaccessibility\">Build for accessibility</h2>\n<p>Most of the validation library on the market does not take accessibility seriously. They are either rely on the developer implement the a11y attributes (e.g. <code>required</code>) along the library; or provide a complete solution but it may not be exactly what you need (and sometime can be REALLY heavy too).</p>\n<p>Here we are trying work with the native form validity API from the browser and integrate with it.</p>\n<pre><code class=\"hbs language-hbs\">&lt;ValidatorContainer as |v|&gt;\n  &lt;v.validity @model={{hash email=this.email}} as |validity|&gt;\n    &lt;input\n      {{on 'input' this.onInput}}\n      type='email'\n      name='email'\n      required\n      value={{this.email}}\n    /&gt;\n    {{#if validity.errorMessage.email}}\n      &lt;p data-test-error&gt;{{validity.errorMessage.email}}&lt;/p&gt;\n    {{/if}}\n  &lt;/v.validity&gt;\n  &lt;p&gt;\n    &lt;button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    &gt;\n      save\n    &lt;/button&gt;\n  &lt;/p&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<p>In this example, we solely rely on the native <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation\">constraint validation</a> by browser, which are the <code>required</code> and <code>email</code> attributes. When any invalid data identified, the validation component will <strong>collect</strong> them automatically and surface to the <code>errorMessage</code> prop from <code>yield</code> object. Meanwhile, while the form remains invalid, <code>isValid</code> is set to <code>false</code>. Which is extremely helpful to convey this so you can decide to disable the button until the issue is fixed.</p>\n<p>When engaging the validation with <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation\">constraint validation API</a>. The default error message from the browser will be exposed in the <code>errorMessage</code> object, you can choose the customize them by declaring the error message of your own see <a href=\"/advanced-usage/customize-error-message\">this doc</a> for more detail.</p>","content":"# Welcome\n\nThis add-on aims to resolve the form validation on your WEB development. Yes, it can be straightforward build a simple solution by listening the `input` event and disable the `continue` button until it's correct. But that's clearly not always the case, especially when the project involve tons of user input. Normally a form validation library can ease the pain and setup a certain standard for consistency. Well, this is one of them, however, we are trying build a tool that is more versatile and not stop you the way.\n\n## Build for accessibility\n\nMost of the validation library on the market does not take accessibility seriously. They are either rely on the developer implement the a11y attributes (e.g. `required`) along the library; or provide a complete solution but it may not be exactly what you need (and sometime can be REALLY heavy too).\n\nHere we are trying work with the native form validity API from the browser and integrate with it.\n\n```hbs\n<ValidatorContainer as |v|>\n  <v.validity @model={{hash email=this.email}} as |validity|>\n    <input\n      {{on 'input' this.onInput}}\n      type='email'\n      name='email'\n      required\n      value={{this.email}}\n    />\n    {{#if validity.errorMessage.email}}\n      <p data-test-error>{{validity.errorMessage.email}}</p>\n    {{/if}}\n  </v.validity>\n  <p>\n    <button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    >\n      save\n    </button>\n  </p>\n</ValidatorContainer>\n```\n\nIn this example, we solely rely on the native [constraint validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation) by browser, which are the `required` and `email` attributes. When any invalid data identified, the validation component will **collect** them automatically and surface to the `errorMessage` prop from `yield` object. Meanwhile, while the form remains invalid, `isValid` is set to `false`. Which is extremely helpful to convey this so you can decide to disable the button until the issue is fixed.\n\nWhen engaging the validation with [constraint validation API](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation). The default error message from the browser will be exposed in the `errorMessage` object, you can choose the customize them by declaring the error message of your own see [this doc](/advanced-usage/customize-error-message) for more detail."}}}