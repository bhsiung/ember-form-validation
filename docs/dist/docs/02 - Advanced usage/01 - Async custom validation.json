{"data":{"type":"contents","id":"02 - Advanced usage/01 - Async custom validation","attributes":{"html":"<h1 id=\"validatecustomfunctionasynchronously\">Validate custom function asynchronously</h1>\n<p>It is very common for business logic to perform validation on the server side dynamically.\nFor certain case, simply define the custom validator function as <code>async</code> and invoke <code>AJAX</code> there.\nThe wrapper will collect the error just like the synchronous ones.</p>\n<p>The following example instruments a custom validation which execute asynchronously,\nan error message will display with value starting with <code>invalid</code> (e.g. <code>invalid@gmail.com</code>)</p>\n<pre><code class=\"hbs language-hbs\">&lt;ValidatorContainer as |v|&gt;\n  &lt;v.validity\n    @validator={{this.customValidator}}\n    @model={{hash email=this.email}}\n    as |validity|\n  &gt;\n    &lt;input\n      placeholder=\"username@email.com\"\n      autocomplete=\"off\"\n      type=\"email\"\n      name=\"email\"\n      data-test-email\n      value={{this.email}}\n      required\n      {{on 'input' this.onInput}}\n    /&gt;\n    {{#if validity.loading}}\n      &lt;p data-test-loading&gt;loading for validation&lt;/p&gt;\n    {{else if validity.errorMessage.email}}\n      &lt;p data-test-error&gt;{{validity.errorMessage.email}}&lt;/p&gt;\n    {{/if}}\n  &lt;/v.validity&gt;\n  &lt;p&gt;\n    &lt;button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    &gt;\n      save\n    &lt;/button&gt;\n  &lt;/p&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<pre><code>@action\nasync customValidator({ email }) {\n  return new Promise((resolve, reject) =&gt; {\n    if (/^invalid/.test(email)) {\n      later(null, () =&gt; resolve({ email: 'ASYNC_VALIDATION_ERROR' }), 1000);\n    } else {\n      later(null, () =&gt; resolve({ email: '' }), 1000);\n    }\n  });\n}\n</code></pre>\n<p>While waiting for the async function to return, we did 2 things help you to manage the form state</p>\n<ul>\n<li><code>isValid</code> in the form level (<code>ValidatorContainer</code>) is set to <code>false</code>, it can be used to prevent the user submitting the form while waiting for the validation result</li>\n<li><code>loading</code> in the wrapper level (<code>validity</code>) is set to true, it can be used to toggle the loading spinner.</li>\n</ul>","content":"# Validate custom function asynchronously\n\nIt is very common for business logic to perform validation on the server side dynamically.\nFor certain case, simply define the custom validator function as `async` and invoke `AJAX` there.\nThe wrapper will collect the error just like the synchronous ones.\n\nThe following example instruments a custom validation which execute asynchronously,\nan error message will display with value starting with `invalid` (e.g. `invalid@gmail.com`)\n\n```hbs\n<ValidatorContainer as |v|>\n  <v.validity\n    @validator={{this.customValidator}}\n    @model={{hash email=this.email}}\n    as |validity|\n  >\n    <input\n      placeholder=\"username@email.com\"\n      autocomplete=\"off\"\n      type=\"email\"\n      name=\"email\"\n      data-test-email\n      value={{this.email}}\n      required\n      {{on 'input' this.onInput}}\n    />\n    {{#if validity.loading}}\n      <p data-test-loading>loading for validation</p>\n    {{else if validity.errorMessage.email}}\n      <p data-test-error>{{validity.errorMessage.email}}</p>\n    {{/if}}\n  </v.validity>\n  <p>\n    <button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    >\n      save\n    </button>\n  </p>\n</ValidatorContainer>\n```\n```\n@action\nasync customValidator({ email }) {\n  return new Promise((resolve, reject) => {\n    if (/^invalid/.test(email)) {\n      later(null, () => resolve({ email: 'ASYNC_VALIDATION_ERROR' }), 1000);\n    } else {\n      later(null, () => resolve({ email: '' }), 1000);\n    }\n  });\n}\n```\nWhile waiting for the async function to return, we did 2 things help you to manage the form state\n- `isValid` in the form level (`ValidatorContainer`) is set to `false`, it can be used to prevent the user submitting the form while waiting for the validation result\n- `loading` in the wrapper level (`validity`) is set to true, it can be used to toggle the loading spinner."}}}