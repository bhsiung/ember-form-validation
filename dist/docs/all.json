{"data":[{"type":"contents","id":"01 - API","attributes":{"html":"<h1 id=\"validatorcontainer\">ValidatorContainer</h1>\n<p>this is the only component that is needed to setup to get everything done.</p>\n<h2 id=\"validationcontainer\"><code>ValidationContainer</code></h2>\n<h3 id=\"properties\">Properties</h3>\n<h4 id=\"validationgboolean\">validationg <code>Boolean</code></h4>\n<p>An optional prop that determine if validation mode is active or not, it can be useful for forms that does NOT proceed validating until the first attempt of submission. However, the value will be set to true while when the user invoke the <code>checkFrom</code> action.</p>\n<h3 id=\"yieldproperties\">Yield properties</h3>\n<h4 id=\"validitywrappercomponent\">validity <code>WrapperComponent</code></h4>\n<p>A wrapper component that allow the user to defne the custom validation functions per input (or related inputs).</p>\n<h4 id=\"checkformcallback\">checkForm <code>Callback</code></h4>\n<p>A proxy function examine the correctness of the corrent form data. If the form is correct, the chained callback function will be invoke.</p>\n<h4 id=\"isvalidboolean\">isValid <code>Boolean</code></h4>\n<p>A flag to determine if everything on the form is valid</p>\n<h2 id=\"example\">Example</h2>\n<pre><code>&lt;ValidatorContainer @validating={{false}} as |v|&gt;\n  &lt;v.validity&gt;\n    ...\n  &lt;/v.validity&gt;\n  &lt;button\n    disabled={{not v.isValid}}\n    {{on 'click' (fn v.checkForm this.onSubmit)}}\n  &gt;\n    save\n  &lt;/button&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<h2 id=\"wrappercomponent\"><code>WrapperComponent</code></h2>\n<p>Each input (or related input group) shall be wrapped within this components. You can specify the dedicated validation function receive the error message of the input element.</p>\n<h2 id=\"example-1\">Example</h2>\n<pre><code>&lt;ValidatorContainer as |v|&gt;\n  &lt;v.validity\n    @model={{hash email=this.email}}\n    @validator={{this.isGmail}}\n    as |validity|\n  &gt;\n    &lt;input name=\"email\" required /&gt;\n    &lt;p&gt;{{validity.errorMessage.email}}&lt;/p&gt;\n  &lt;/v.validity&gt;\n  &lt;button\n    disabled={{not v.isValid}}\n    {{on 'click' (fn v.checkForm this.onSubmit)}}\n  &gt;\n    save\n  &lt;/button&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<h3 id=\"properties-1\">Properties</h3>\n<h4 id=\"modelobject\">model <code>Object</code></h4>\n<p>The wrapper component subscribe the change of user input thru this property. Keep in mind that the strcuture of the <code>model</code> is a key-value hash, the <code>key</code> represents the <code>name</code> attribute of the input element.</p>\n<h4 id=\"validatorcallbackcallback\">validator <code>Callback|Callback[]</code></h4>\n<p>An optional function (or functions) can be passed here as custom validator, the function will be perform <strong>AFTER</strong> the element passed the native constraint validation.</p>\n<p>Here is an example of callback functions:</p>\n<pre><code class=\"js language-js\">function isGmail(model) {\n  const { email } = mdoel;\n  return /.+@gmail\\.com$/.test(email)\n    ? { email: '' }\n    : { email: 'Only gmail account is allowed' };\n}\n</code></pre>\n<p>The argument <code>model</code> is perceived from the latest <a href=\"#modelobject\"><code>model</code></a> property from the component property assigned to <a href=\"#wrappercomponent\"><code>WrapperComponent</code></a>; and it returns an error message object which contributes to the production of <a href=\"#errormessageobject\"><code>errorMessage</code></a> from the yield properties.</p>\n<!-- TODO @bear add more content -->\n<h3 id=\"yieldproperties-1\">Yield properties</h3>\n<h4 id=\"errormessageobject\">errorMessage <code>Object</code></h4>\n<p>TBD</p>\n<!-- TODO bear add more content -->","content":"# ValidatorContainer\n\nthis is the only component that is needed to setup to get everything done.\n\n## `ValidationContainer`\n\n### Properties\n\n#### validationg `Boolean`\nAn optional prop that determine if validation mode is active or not, it can be useful for forms that does NOT proceed validating until the first attempt of submission. However, the value will be set to true while when the user invoke the `checkFrom` action.\n\n### Yield properties\n\n#### validity `WrapperComponent`\nA wrapper component that allow the user to defne the custom validation functions per input (or related inputs).\n\n#### checkForm `Callback`\nA proxy function examine the correctness of the corrent form data. If the form is correct, the chained callback function will be invoke.\n\n#### isValid `Boolean`\nA flag to determine if everything on the form is valid\n\n## Example\n```\n<ValidatorContainer @validating={{false}} as |v|>\n  <v.validity>\n    ...\n  </v.validity>\n  <button\n    disabled={{not v.isValid}}\n    {{on 'click' (fn v.checkForm this.onSubmit)}}\n  >\n    save\n  </button>\n</ValidatorContainer>\n```\n\n## `WrapperComponent`\nEach input (or related input group) shall be wrapped within this components. You can specify the dedicated validation function receive the error message of the input element.\n\n## Example\n```\n<ValidatorContainer as |v|>\n  <v.validity\n    @model={{hash email=this.email}}\n    @validator={{this.isGmail}}\n    as |validity|\n  >\n    <input name=\"email\" required />\n    <p>{{validity.errorMessage.email}}</p>\n  </v.validity>\n  <button\n    disabled={{not v.isValid}}\n    {{on 'click' (fn v.checkForm this.onSubmit)}}\n  >\n    save\n  </button>\n</ValidatorContainer>\n```\n\n### Properties\n\n#### model `Object`\nThe wrapper component subscribe the change of user input thru this property. Keep in mind that the strcuture of the `model` is a key-value hash, the `key` represents the `name` attribute of the input element.\n\n#### validator `Callback|Callback[]`\nAn optional function (or functions) can be passed here as custom validator, the function will be perform **AFTER** the element passed the native constraint validation.\n\nHere is an example of callback functions:\n```js\nfunction isGmail(model) {\n  const { email } = mdoel;\n  return /.+@gmail\\.com$/.test(email)\n    ? { email: '' }\n    : { email: 'Only gmail account is allowed' };\n}\n```\nThe argument `model` is perceived from the latest [`model`](#modelobject) property from the component property assigned to [`WrapperComponent`](#wrappercomponent); and it returns an error message object which contributes to the production of [`errorMessage`](#errormessageobject) from the yield properties.\n<!-- TODO @bear add more content -->\n\n### Yield properties\n\n#### errorMessage `Object`\nTBD\n<!-- TODO bear add more content -->"}},{"type":"contents","id":"02 - Advanced usage/01 - Async custom validation","attributes":{"html":"<h1 id=\"validatecustomfunctionasynchronously\">Validate custom function asynchronously</h1>\n<p>It is very common for business logic to perform validation on the server side dynamically.\nFor certain case, simply define the custom validator function as <code>async</code> and invoke <code>AJAX</code> there.\nThe wrapper will collect the error just like the synchronous ones.</p>\n<p>The following example instruments a custom validation which execute asynchronously,\nan error message will display with value starting with <code>invalid</code> (e.g. <code>invalid@gmail.com</code>)</p>\n<pre><code class=\"hbs language-hbs\">&lt;ValidatorContainer as |v|&gt;\n  &lt;v.validity\n    @validator={{this.customValidator}}\n    @model={{hash email=this.email}}\n    as |validity|\n  &gt;\n    &lt;input\n      placeholder=\"username@email.com\"\n      autocomplete=\"off\"\n      type=\"email\"\n      name=\"email\"\n      data-test-email\n      value={{this.email}}\n      required\n      {{on 'input' this.onInput}}\n    /&gt;\n    {{#if validity.loading}}\n      &lt;p data-test-loading&gt;loading for validation&lt;/p&gt;\n    {{else if validity.errorMessage.email}}\n      &lt;p data-test-error&gt;{{validity.errorMessage.email}}&lt;/p&gt;\n    {{/if}}\n  &lt;/v.validity&gt;\n  &lt;p&gt;\n    &lt;button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    &gt;\n      save\n    &lt;/button&gt;\n  &lt;/p&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<pre><code>@action\nasync customValidator({ email }) {\n  return new Promise((resolve, reject) =&gt; {\n    if (/^invalid/.test(email)) {\n      later(null, () =&gt; resolve({ email: 'ASYNC_VALIDATION_ERROR' }), 1000);\n    } else {\n      later(null, () =&gt; resolve({ email: '' }), 1000);\n    }\n  });\n}\n</code></pre>\n<p>While waiting for the async function to return, we did 2 things help you to manage the form state</p>\n<ul>\n<li><code>isValid</code> in the form level (<code>ValidatorContainer</code>) is set to <code>false</code>, it can be used to prevent the user submitting the form while waiting for the validation result</li>\n<li><code>loading</code> in the wrapper level (<code>validity</code>) is set to true, it can be used to toggle the loading spinner.</li>\n</ul>","content":"# Validate custom function asynchronously\n\nIt is very common for business logic to perform validation on the server side dynamically.\nFor certain case, simply define the custom validator function as `async` and invoke `AJAX` there.\nThe wrapper will collect the error just like the synchronous ones.\n\nThe following example instruments a custom validation which execute asynchronously,\nan error message will display with value starting with `invalid` (e.g. `invalid@gmail.com`)\n\n```hbs\n<ValidatorContainer as |v|>\n  <v.validity\n    @validator={{this.customValidator}}\n    @model={{hash email=this.email}}\n    as |validity|\n  >\n    <input\n      placeholder=\"username@email.com\"\n      autocomplete=\"off\"\n      type=\"email\"\n      name=\"email\"\n      data-test-email\n      value={{this.email}}\n      required\n      {{on 'input' this.onInput}}\n    />\n    {{#if validity.loading}}\n      <p data-test-loading>loading for validation</p>\n    {{else if validity.errorMessage.email}}\n      <p data-test-error>{{validity.errorMessage.email}}</p>\n    {{/if}}\n  </v.validity>\n  <p>\n    <button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    >\n      save\n    </button>\n  </p>\n</ValidatorContainer>\n```\n```\n@action\nasync customValidator({ email }) {\n  return new Promise((resolve, reject) => {\n    if (/^invalid/.test(email)) {\n      later(null, () => resolve({ email: 'ASYNC_VALIDATION_ERROR' }), 1000);\n    } else {\n      later(null, () => resolve({ email: '' }), 1000);\n    }\n  });\n}\n```\nWhile waiting for the async function to return, we did 2 things help you to manage the form state\n- `isValid` in the form level (`ValidatorContainer`) is set to `false`, it can be used to prevent the user submitting the form while waiting for the validation result\n- `loading` in the wrapper level (`validity`) is set to true, it can be used to toggle the loading spinner."}},{"type":"contents","id":"02 - Advanced usage/02 - Customize error message","attributes":{"html":"<h1 id=\"customizeerrormessageforconstraintvalidation\">Customize error message for constraint validation</h1>\n<p>TBD</p>","content":"# Customize error message for constraint validation\nTBD"}},{"type":"contents","id":"02 - Advanced usage/03 - Editable content","attributes":{"html":"<h1 id=\"forartificialinputelements\">For artificial input elements</h1>\n<p>TBD</p>","content":"# For artificial input elements\nTBD"}},{"type":"contents","id":"02 - Advanced usage/04 - Multiple inputs within single wrapper","attributes":{"html":"<h1 id=\"relatedinputs\">Related inputs</h1>\n<p>TBD</p>","content":"# Related inputs\n\nTBD"}},{"type":"contents","id":"index","attributes":{"html":"<h1 id=\"welcome\">Welcome</h1>\n<p>This add-on aims to resolve the form validation on your WEB development. Yes, it can be straightforward build a simple solution by listening the <code>input</code> event and disable the <code>continue</code> button until it's correct. But that's clearly not always the case, especially when the project involve tons of user input. Normally a form validation library can ease the pain and setup a certain standard for consistency. Well, this is one of them, however, we are trying build a tool that is more versatile and not stop you the way.</p>\n<h2 id=\"buildforaccessibility\">Build for accessibility</h2>\n<p>Most of the validation library on the market does not take accessibility seriously. They are either rely on the developer implement the a11y attributes (e.g. <code>required</code>) along the library; or provide a complete solution but it may not be exactly what you need (and sometime can be REALLY heavy too).</p>\n<p>Here we are trying work with the native form validity API from the browser and integrate with it.</p>\n<pre><code class=\"hbs language-hbs\">&lt;ValidatorContainer as |v|&gt;\n  &lt;v.validity @model={{hash email=this.email}} as |validity|&gt;\n    &lt;input\n      {{on 'input' this.onInput}}\n      type='email'\n      name='email'\n      required\n      value={{this.email}}\n    /&gt;\n    {{#if validity.errorMessage.email}}\n      &lt;p data-test-error&gt;{{validity.errorMessage.email}}&lt;/p&gt;\n    {{/if}}\n  &lt;/v.validity&gt;\n  &lt;p&gt;\n    &lt;button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    &gt;\n      save\n    &lt;/button&gt;\n  &lt;/p&gt;\n&lt;/ValidatorContainer&gt;\n</code></pre>\n<p>In this example, we solely rely on the native <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation\">constraint validation</a> by browser, which are the <code>required</code> and <code>email</code> attributes. When any invalid data identified, the validation component will <strong>collect</strong> them automatically and surface to the <code>errorMessage</code> prop from <code>yield</code> object. Meanwhile, while the form remains invalid, <code>isValid</code> is set to <code>false</code>. Which is extremely helpful to convey this so you can decide to disable the button until the issue is fixed.</p>\n<p>When engaging the validation with <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation\">constraint validation API</a>. The default error message from the browser will be exposed in the <code>errorMessage</code> object, you can choose the customize them by declaring the error message of your own see <a href=\"/advanced-usage/customize-error-message\">this doc</a> for more detail.</p>","content":"# Welcome\n\nThis add-on aims to resolve the form validation on your WEB development. Yes, it can be straightforward build a simple solution by listening the `input` event and disable the `continue` button until it's correct. But that's clearly not always the case, especially when the project involve tons of user input. Normally a form validation library can ease the pain and setup a certain standard for consistency. Well, this is one of them, however, we are trying build a tool that is more versatile and not stop you the way.\n\n## Build for accessibility\n\nMost of the validation library on the market does not take accessibility seriously. They are either rely on the developer implement the a11y attributes (e.g. `required`) along the library; or provide a complete solution but it may not be exactly what you need (and sometime can be REALLY heavy too).\n\nHere we are trying work with the native form validity API from the browser and integrate with it.\n\n```hbs\n<ValidatorContainer as |v|>\n  <v.validity @model={{hash email=this.email}} as |validity|>\n    <input\n      {{on 'input' this.onInput}}\n      type='email'\n      name='email'\n      required\n      value={{this.email}}\n    />\n    {{#if validity.errorMessage.email}}\n      <p data-test-error>{{validity.errorMessage.email}}</p>\n    {{/if}}\n  </v.validity>\n  <p>\n    <button\n      disabled={{not v.isValid}}\n      {{on 'click' (fn v.checkForm this.onSubmit)}}\n    >\n      save\n    </button>\n  </p>\n</ValidatorContainer>\n```\n\nIn this example, we solely rely on the native [constraint validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation) by browser, which are the `required` and `email` attributes. When any invalid data identified, the validation component will **collect** them automatically and surface to the `errorMessage` prop from `yield` object. Meanwhile, while the form remains invalid, `isValid` is set to `false`. Which is extremely helpful to convey this so you can decide to disable the button until the issue is fixed.\n\nWhen engaging the validation with [constraint validation API](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Constraint_validation). The default error message from the browser will be exposed in the `errorMessage` object, you can choose the customize them by declaring the error message of your own see [this doc](/advanced-usage/customize-error-message) for more detail."}}]}